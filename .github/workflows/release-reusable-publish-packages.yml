name: Reusable - Publish Package

on:
  workflow_call:
    inputs:
      tag:
        description: Current final release tag (e.g., polkadot-stableYYMM)
        required: true
        type: string
      distribution:
        description: Distribution where to publish package (e.g., release, staging)
        required: true
        type: string
      package_type:
        description: Type of package to publish (deb or rpm)
        required: true
        type: string 
      aws_repo_base_path:
        description: Base S3 path for package repositories
        required: true
        type: string
      cloudfront_distribution_id:
        description: CloudFront Distribution ID for cache invalidation
        required: true
        type: string
    secrets:
      upstream_content_sync_app_key:
        required: true
      aws_release_access_key_id:
        required: true
      aws_release_secret_access_key:
        required: true
      pgp_kms_key:
        required: true
      pgp_kms_hash:
        required: true
      aws_default_region:
        required: true
      aws_access_key_id:
        required: true
      aws_secret_access_key:
        required: true
 
jobs:
  check-synchronization:
    uses: paritytech-release/sync-workflows/.github/workflows/check-synchronization.yml@main
    secrets:
      fork_writer_app_key: ${{ secrets.upstream_content_sync_app_key }}

  validate-inputs:
    needs: [check-synchronization]
    if: ${{ needs.check-synchronization.outputs.checks_passed }} == 'true'
    runs-on: ubuntu-latest
    outputs:
        release_tag: ${{ steps.validate_inputs.outputs.release_tag }}
    steps:
      - name: Checkout sources
        uses: actions/checkout@d632683dd7b4114ad314bca15554477dd762a938 # v4.2.0

      - name: Validate package type
        if: ${{ inputs.package_type != 'deb' && inputs.package_type != 'rpm' }}
        run: |
          echo "Error: package_type must be either 'deb' or 'rpm'"
          exit 1

      - name: Validate inputs
        id: validate_inputs
        run: |
          # Source common library for helper functions
          . ./.github/scripts/common/lib.sh
          RELEASE_TAG=$(validate_stable_tag ${{ inputs.tag }})
          echo "release_tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT

  fetch-artifacts-from-s3:
    runs-on: ubuntu-latest
    needs: [validate-inputs]
    environment: release
    env:
      REPO: ${{ github.repository }}
      VERSION: ${{ needs.validate-inputs.outputs.release_tag }}
      AWS_ACCESS_KEY_ID: ${{ secrets.aws_release_access_key_id }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.aws_release_secret_access_key }}
      AWS_DEFAULT_REGION: ${{ secrets.aws_default_region }}
    outputs:
      NODE_VERSION: ${{ steps.fetch_artifacts_from_s3.outputs.NODE_VERSION }}
    steps:
      - name: Checkout sources
        uses: actions/checkout@d632683dd7b4114ad314bca15554477dd762a938 # v4.2.0

      - name: List available RPMs in S3 for debugging
        run: |
          S3_PATH="s3://releases-package-repos/polkadot/${{ env.VERSION }}"
          echo "Listing .rpm files in ${S3_PATH}..."
          aws s3 ls "${S3_PATH}" --recursive || echo "No files found in ${S3_PATH}"

      - name: Fetch rc artifacts or release artifacts from s3 based on version
        id: fetch_artifacts_from_s3
        run: |
          . ./.github/scripts/common/lib.sh
          NODE_VERSION="$(get_polkadot_node_version_from_code)"
          echo "NODE_VERSION=${NODE_VERSION}" >> $GITHUB_OUTPUT

          # Fetch specific package type artifact (deb or rpm)
          if [[ "${{ inputs.package_type }}" == "deb" ]]; then
            fetch_debian_package_from_s3 polkadot
          elif [[ "${{ inputs.package_type }}" == "rpm" ]]; then
            fetch_rpm_package_from_s3 polkadot
          fi

      - name: Upload artifacts for later jobs
        uses: actions/upload-artifact@5d5d22a31266ced268874388b861e4b58bb5c2f3 # v4.3.1
        with:
          name: release-artifacts
          path: release-artifacts/polkadot/*.${{ inputs.package_type }}

  publish-package:
    runs-on: ubuntu-latest
    needs: [fetch-artifacts-from-s3]
    environment: release
    env:
      AWS_DEFAULT_REGION: ${{ secrets.aws_default_region }}
      AWS_REPO_PATH: "${{ inputs.aws_repo_base_path }}/${{ inputs.package_type }}"
      LOCAL_REPO_PATH: ${{ github.workspace }}/${{ inputs.package_type }}
      NODE_VERSION: ${{ needs.fetch-artifacts-from-s3.outputs.NODE_VERSION }}
    steps:
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip reprepro rpm createrepo-c

          python3 -m pip install --user awscli "pgpkms @ git+https://github.com/paritytech-release/pgpkms.git@e7f806f99e9be5c52f0b4a536b7d4ef9c3e695ed"

          # Ensure ~/.local/bin is in PATH right now and for later steps
          export PATH=$HOME/.local/bin:$PATH
          echo "$HOME/.local/bin" >> $GITHUB_PATH

          # Export to GITHUB_ENV (this time they wonâ€™t be empty)
          echo "PGPKMS_REPREPRO_PATH=$(which pgpkms-reprepro)" >> $GITHUB_ENV
          echo "PGPKMS_RPMSIGN_PATH=$(which pgpkms-rpmsign)" >> $GITHUB_ENV

      - name: Checkout sources
        uses: actions/checkout@d632683dd7b4114ad314bca15554477dd762a938 # v4.2.0

      - name: Download artifacts from previous job
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
        with:
          name: release-artifacts
          path: release-artifacts

      - name: Debug pgpkms install
        run: |
          echo "Checking installed pgpkms scripts..."
          ls -l $HOME/.local/bin
          which pgpkms || true
          which pgpkms-reprepro || true
          which pgpkms-rpmsign || true

      - name: Setup local deb repo config
        if: ${{ inputs.package_type == 'deb' }}
        run: |
          sed -i "s|^SignWith:.*|SignWith: ! ${PGPKMS_REPREPRO_PATH}|" ${{ github.workspace }}/.github/scripts/release/distributions
          mkdir -p "$LOCAL_REPO_PATH/conf"
          cp ${{ github.workspace }}/.github/scripts/release/distributions "$LOCAL_REPO_PATH/conf/distributions"

      - name: Sync repo, import keys, sign, and update metadata
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.aws_access_key_id }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.aws_secret_access_key }}
          PGP_KMS_KEY: ${{ secrets.pgp_kms_key }}
          PGP_KMS_HASH: ${{ secrets.pgp_kms_hash }}
        run: |
          # --- Sync Repo from S3 ---
          mkdir -p "$LOCAL_REPO_PATH"
          if [[ "${{ inputs.package_type }}" == "deb" ]]; then
            aws s3 sync "$AWS_REPO_PATH/db" "$LOCAL_REPO_PATH/db" || true
            aws s3 sync "$AWS_REPO_PATH/pool" "$LOCAL_REPO_PATH/pool" || true
            aws s3 sync "$AWS_REPO_PATH/dists" "$LOCAL_REPO_PATH/dists" || true
          elif [[ "${{ inputs.package_type }}" == "rpm" ]]; then
            aws s3 sync "$AWS_REPO_PATH" "$LOCAL_REPO_PATH" || true
          fi

          . ./.github/scripts/common/lib.sh
          import_gpg_keys

          # --- Add Package to Repo and Sign ---
          if [[ "${{ inputs.package_type }}" == "deb" ]]; then
            debname=$(find release-artifacts/ -name 'polkadot_*.deb' | head -n 1)
            reprepro -b "$LOCAL_REPO_PATH" includedeb "${{ inputs.distribution }}" "$debname"

          elif [[ "${{ inputs.package_type }}" == "rpm" ]]; then
            echo "Running pgpkms dry-run test..."
            echo "hello world" > testfile.txt
            /home/runner/.local/bin/pgpkms sign --input testfile.txt --output testfile.sig
            ls -l testfile*

            rpmname=$(find release-artifacts/ -name 'polkadot-*.rpm' | head -n 1)

            echo "Signing package with pgpkms (via AWS KMS)..."
            chmod +x .github/scripts/pgpkms-gpg-wrapper.sh
            cp .github/workflows/rpmmacros $HOME/.rpmmacros

            echo "Dumping rpm gpg-related macros..."
            rpm --showrc | grep gpg || true
            echo "Contents of .rpmmacros:"
            cat $HOME/.rpmmacros
            rpm --addsign "$rpmname"

            echo "Copying signed package to local repo..."
            cp "$rpmname" "$LOCAL_REPO_PATH/"

            echo "Updating repository metadata..."
            createrepo_c --update "$LOCAL_REPO_PATH"
          fi

      - name: Upload updated repo to S3
        env:
          AWS_ACCESS_KEY_ID:  ${{ secrets.aws_release_access_key_id }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.aws_release_secret_access_key }}
        run: |
          aws s3 sync "$LOCAL_REPO_PATH" "$AWS_REPO_PATH" --acl public-read
          aws cloudfront create-invalidation --distribution-id ${{ inputs.cloudfront_distribution_id }} --paths '/${{ inputs.package_type }}/*'
